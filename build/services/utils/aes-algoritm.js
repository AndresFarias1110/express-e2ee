"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgoritmAES = void 0;
var CryptoJS = require("crypto-js");
var array_utils_1 = require("./array-utils");
/**
 * Operation modes class: Cipher block chaining
 */
var AlgoritmAES = /** @class */ (function () {
    /**
     * The constructor for operation modes class
     * This inits data, key, block size, mode, iv (initialization vector)
     * @param data The data used for encrypt.
     * @param key The key used for symetric encryption/decryption
     * @param blockSize The block size for operation mode
     * @param mode The operation mode used for encryption/decryption process
     */
    function AlgoritmAES(data, key, blockSize, mode) {
        var _this = this;
        if (data === void 0) { data = null; }
        if (key === void 0) { key = null; }
        if (blockSize === void 0) { blockSize = null; }
        if (mode === void 0) { mode = null; }
        /**
         * Constant string of CBC mode operation
         * @example 'cbc'
         */
        this.M_CBC = 'cbc';
        /**
         * The AES type for encryption/decryption.
         * @example 192
         */
        this.cipher = 0;
        /**
         * The padding to be applied after or before encryption
         * @example CryptoJS.pad.Pkcs7
         */
        this.padding = CryptoJS.pad.NoPadding;
        /**
         * Set the block size (128, 192, 256).
         * @param blockSize The block size of the key
         * @returns void
         */
        this.setBlockSize = function (blockSize) {
            switch (blockSize) {
                case 128:
                    _this.cipher = 128;
                    break;
                case 192:
                    _this.cipher = 192;
                    break;
                case 256:
                    _this.cipher = 256;
                    break;
            }
        };
        /**
         * This sets the new padding for AES operation mode.
         * @param padding The padding selection before/after encryption
         */
        this.setPadding = function (padding) {
            if (padding === 'PKCS7') {
                _this.padding = CryptoJS.pad.Pkcs7;
            }
            else {
                _this.padding = CryptoJS.pad.NoPadding;
            }
        };
        /**
         * The mode to be selected for crypt and decrypt
         * @param mode The mode of operation to be passed as param
         * @returns void
         */
        this.setMode = function (mode) {
            if (mode === _this.M_CBC) {
                _this.mode = CryptoJS.mode.CBC;
            }
            else {
                _this.mode = CryptoJS.mode.ECB;
            }
        };
        /**
         * Gets the block size AES key
         * @returns number
         */
        this.getCipher = function () {
            return _this.cipher;
        };
        /**
         * Init AES object using symetric key.
         * Checks if the instance is OperationMode type
         * If there are no iv (initialization vector) creates one, ohterwise throws an error
         * Create an array called as lastCipherBlock using iv
         * Instance AES object
         * @param key The symetric key used for encryption/decryption process
         * @param iv The initialization vector used for any operation mode
         * @throws Error It is thrown when IV vector has invalid length
         * @returns void
         */
        this.initAESAlgorithm = function (key, iv, padding) {
            _this.setPadding(padding);
            if (!iv) {
                iv = array_utils_1.ArrayUtils.createArray(16);
            }
            else if (iv.length !== 16) {
                throw new Error('invalid initialation vector size (must be 16 bytes)');
            }
            _this.initVector = iv;
            _this.key = key;
        };
        /**
         * To encrypt any plaintext generated by AES algorithm using CBC operation mode.
         * 1- Detect if plaintext Array is in utf8 format.
         * 2- If plaintext has a length divisible by 16 continue, else, throws an error.
         * 3- Create ciphertext utf8 array.
         * 4- For each 16-length block ciphertext array, do =>
         *   copy each 16-length block to block variable.
         *   Encrypt using AES algorithm that block.
         *   make xor operation between block and last ciphertext at index j
         *   update lastciphertext block by encrypt block.
         *   update ciphertext by current lastcipherblock
         * 5- return ciphertext.
         * @param plaintext The plaintext used for encryption AES mode operation
         * @throws Error It is thrown when plaintext length is not divisible by 16
         * @returns Uint8Array The encrypted plaintext
         */
        this.encrypt = function (plaintext) {
            plaintext = array_utils_1.ArrayUtils.coerceArray(plaintext);
            var encryptedWordArray = CryptoJS.AES.encrypt(array_utils_1.ArrayUtils.convertU8arrayB64().parse(plaintext), array_utils_1.ArrayUtils.convertU8arrayB64().parse(_this.key), {
                iv: array_utils_1.ArrayUtils.convertU8arrayB64().parse(_this.initVector),
                mode: CryptoJS.mode.CBC,
                padding: _this.padding,
            });
            return array_utils_1.ArrayUtils.convertU8arrayB64().stringify(encryptedWordArray.ciphertext);
        };
        /**
         * To decrypt any ciphertext generated by AES algorithm using CBC operation mode.
         * 1- Detect if ciphertext Array is in utf8 format.
         * 2- If ciphertext has a length divisible by 16 continue, else, throws an error.
         * 3- Create plaintext utf8 array.
         * 4- For each 16-length block ciphertext array, do =>
         *   copy each 16-length block to block variable.
         *   Decrypt using AES algorithm that block.
         *   make xor operation between block at index j and last ciphertext
         *   update lastciphertext block by actual ciphertext.
         * 5- return plaintext.
         * @param ciphertext The ciphertext to be decrypted using AES
         * @throws Error It is thrown when ciphertext length is not divisible by 16.
         * @returns Uint8Array The original plaintext
         */
        this.decrypt = function (ciphertext) {
            ciphertext = array_utils_1.ArrayUtils.coerceArray(ciphertext);
            var array = {
                ciphertext: array_utils_1.ArrayUtils.convertU8arrayB64().parse(ciphertext),
            };
            var plaintextWordArray = CryptoJS.AES.decrypt(array, array_utils_1.ArrayUtils.convertU8arrayB64().parse(_this.key), {
                iv: array_utils_1.ArrayUtils.convertU8arrayB64().parse(_this.initVector),
                mode: CryptoJS.mode.CBC,
                padding: _this.padding,
            });
            return array_utils_1.ArrayUtils.convertU8arrayB64().stringify(plaintextWordArray);
        };
        this.data = data;
        this.key = key;
        this.setBlockSize(blockSize);
        this.setMode(mode);
        this.initVector = '';
    }
    return AlgoritmAES;
}());
exports.AlgoritmAES = AlgoritmAES;
