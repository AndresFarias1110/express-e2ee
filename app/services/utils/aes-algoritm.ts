var CryptoJS = require('crypto-js');
import { ArrayUtils } from './array-utils';

/**
 * Operation modes class: Cipher block chaining
 */
export class AlgoritmAES {
  /**
   * Constant string of CBC mode operation
   * @example 'cbc'
   */
  M_CBC = 'cbc';
  /**
   * The key to be used for symetric encryption/decryption process AES
   * @example object
   */
  protected key: any;
  /**
   * The AES type for encryption/decryption.
   * @example 192
   */
  protected cipher = 0;
  /**
   * The data to be encrypted/decrypted
   * @example 'Mi texto a cifrar'
   */
  protected data: any;
  /**
   * The operation mode to be used. In this case could be CRYPT_MODE_CBC
   * @example 'CRYPT_MODE_CBC'
   */
  protected mode: any;
  /**
   * The padding to be applied after or before encryption
   * @example CryptoJS.pad.Pkcs7
   */
  protected padding: object = CryptoJS.pad.NoPadding;
  /**
   * The initialization random vector values.
   * @example object
   */
  protected initVector: any;
  /**
   * The constructor for operation modes class
   * This inits data, key, block size, mode, iv (initialization vector)
   * @param data The data used for encrypt.
   * @param key The key used for symetric encryption/decryption
   * @param blockSize The block size for operation mode
   * @param mode The operation mode used for encryption/decryption process
   */
  constructor(data: any = null, key: any = null, blockSize: any = null, mode: any = null) {
    this.data = data;
    this.key = key;
    this.setBlockSize(blockSize);
    this.setMode(mode);
    this.initVector = '';
  }
  /**
   * Set the block size (128, 192, 256).
   * @param blockSize The block size of the key
   * @returns void
   */
  setBlockSize = (blockSize: number): void => {
    switch (blockSize) {
      case 128:
        this.cipher = 128;
        break;
      case 192:
        this.cipher = 192;
        break;
      case 256:
        this.cipher = 256;
        break;
    }
  }
  /**
   * This sets the new padding for AES operation mode.
   * @param padding The padding selection before/after encryption
   */
  setPadding = (padding?: string) => {
    if (padding === 'PKCS7') {
      this.padding = CryptoJS.pad.Pkcs7;
    } else {
      this.padding = CryptoJS.pad.NoPadding;
    }
  }
  /**
   * The mode to be selected for crypt and decrypt
   * @param mode The mode of operation to be passed as param
   * @returns void
   */
  setMode = (mode: string): void => {
    if (mode === this.M_CBC) {
      this.mode = CryptoJS.mode.CBC;
    } else {
      this.mode = CryptoJS.mode.ECB;
    }
  }
  /**
   * Gets the block size AES key
   * @returns number
   */
  getCipher = (): number => {
    return this.cipher;
  }
  /**
   * Init AES object using symetric key.
   * Checks if the instance is OperationMode type
   * If there are no iv (initialization vector) creates one, ohterwise throws an error
   * Create an array called as lastCipherBlock using iv
   * Instance AES object
   * @param key The symetric key used for encryption/decryption process
   * @param iv The initialization vector used for any operation mode
   * @throws Error It is thrown when IV vector has invalid length
   * @returns void
   */
  initAESAlgorithm = (key: any, iv: any, padding?: string): void => {
    this.setPadding(padding);
    if (!iv) {
      iv = ArrayUtils.createArray(16);
    } else if (iv.length !== 16) {
      throw new Error('invalid initialation vector size (must be 16 bytes)');
    }
    this.initVector = iv;
    this.key = key;
  }
  /**
   * To encrypt any plaintext generated by AES algorithm using CBC operation mode.
   * 1- Detect if plaintext Array is in utf8 format.
   * 2- If plaintext has a length divisible by 16 continue, else, throws an error.
   * 3- Create ciphertext utf8 array.
   * 4- For each 16-length block ciphertext array, do =>
   *   copy each 16-length block to block variable.
   *   Encrypt using AES algorithm that block.
   *   make xor operation between block and last ciphertext at index j
   *   update lastciphertext block by encrypt block.
   *   update ciphertext by current lastcipherblock
   * 5- return ciphertext.
   * @param plaintext The plaintext used for encryption AES mode operation
   * @throws Error It is thrown when plaintext length is not divisible by 16
   * @returns Uint8Array The encrypted plaintext
   */
  encrypt = (plaintext: Uint8Array): Uint8Array => {
    plaintext = ArrayUtils.coerceArray(plaintext);
    const encryptedWordArray: any = CryptoJS.AES.encrypt(
      ArrayUtils.convertU8arrayB64().parse(plaintext),
      ArrayUtils.convertU8arrayB64().parse(this.key),
      {
        iv: ArrayUtils.convertU8arrayB64().parse(this.initVector),
        mode: CryptoJS.mode.CBC,
        padding: this.padding,
      }
    );
    return ArrayUtils.convertU8arrayB64().stringify(encryptedWordArray.ciphertext);
  }

  /**
   * To decrypt any ciphertext generated by AES algorithm using CBC operation mode.
   * 1- Detect if ciphertext Array is in utf8 format.
   * 2- If ciphertext has a length divisible by 16 continue, else, throws an error.
   * 3- Create plaintext utf8 array.
   * 4- For each 16-length block ciphertext array, do =>
   *   copy each 16-length block to block variable.
   *   Decrypt using AES algorithm that block.
   *   make xor operation between block at index j and last ciphertext
   *   update lastciphertext block by actual ciphertext.
   * 5- return plaintext.
   * @param ciphertext The ciphertext to be decrypted using AES
   * @throws Error It is thrown when ciphertext length is not divisible by 16.
   * @returns Uint8Array The original plaintext
   */
  decrypt = (ciphertext: Uint8Array): Uint8Array => {
    ciphertext = ArrayUtils.coerceArray(ciphertext);
    const array: any = {
        ciphertext: ArrayUtils.convertU8arrayB64().parse(ciphertext),
    };
    const plaintextWordArray: any = CryptoJS.AES.decrypt(
        array,
      ArrayUtils.convertU8arrayB64().parse(this.key),
      {
        iv: ArrayUtils.convertU8arrayB64().parse(this.initVector),
        mode: CryptoJS.mode.CBC,
        padding: this.padding,
      }
    );
    return ArrayUtils.convertU8arrayB64().stringify(plaintextWordArray);
  }
}
